---
title: Setting Up GraphQL Server to Scale With GraphQL Codegen Server Preset
authors: eddeee888
tags: [graphql, codegen, node, server, typescript]
date: 2023-01-31
description: Structuring GraphQL server the right way enables many teams to work in harmony while minimising runtime risks.
# image: 
# thumbnail: 
---

A GraphQL server is usually the central point where teams must develop their own features while avoiding blocking others. Every team has their own standards and practices. Therefore, if the GraphQL server is not set up in a structure to allow it to scale, development slows down dramatically as more time would be spent on admin tasks and not feature work.

In this blog post we explore the common problems GraphQL servers encounter at scale and recommendations on how to solve them.

## The Easy Problem

### How to Manage Code Ownership

Putting multiple teams in one codebase without clear structure and guidelines is a recipe for disaster. The first team in the codebase usually sets it up a structure that works for them. When a second team joins, they most likely just follows the structure that's already there. The same story happens for every team thereafter. After a few more rounds, development slows down, one reviews the structure and finds themselves staring a codebase that was structured by one team, for one team.

Teams also want their team members to be notified when changes that need reviewed, not on every Pull Request (PR). If you have ever been notified for a change that's unrelated to your team, chances are, the codebase is not structured correctly.

In the example below, Team A is the first to set up the server. They manage `User` and `Auth` related files so they creates `datasources` and `resolvers` folder for these files:

```markdown
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ schema/
â”‚   â”‚   â”œâ”€â”€ datasources/
â”‚   â”‚   â”‚   â”œâ”€â”€ UserDatasource.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ AuthDatasource.ts
â”‚   â”‚   â”œâ”€â”€ resolvers/
â”‚   â”‚   â”‚   â”œâ”€â”€ userResolvers.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ authResolvers.ts
â”‚   â”‚   â”œâ”€â”€ userSchema.graphql
â”‚   â”‚   â”œâ”€â”€ authSchema.graphql
â”‚   â”œâ”€â”€ server.ts
â”‚   â”œâ”€â”€ codegen.yml
```

Then, Team B comes into the codebase. They manage `Book` related files so they add their files following the same structure:

```markdown
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ schema/
â”‚   â”‚   â”œâ”€â”€ datasources/
â”‚   â”‚   â”‚   â”œâ”€â”€ UserDatasource.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ AuthDatasource.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ BookDatasource.ts
â”‚   â”‚   â”œâ”€â”€ resolvers/
â”‚   â”‚   â”‚   â”œâ”€â”€ userResolvers.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ authResolvers.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ bookResolvers.ts
â”‚   â”‚   â”œâ”€â”€ userSchema.graphql
â”‚   â”‚   â”œâ”€â”€ authSchema.graphql
â”‚   â”‚   â”œâ”€â”€ bookSchema.graphql
â”‚   â”œâ”€â”€ server.ts
â”‚   â”œâ”€â”€ codegen.yml
```

While this works at a small scale where everyone knows each others, it would be hard to know who owns what as their could be hundreds of datasources and resolvers. A simple solution is to assign files to owners using GitHub's CODEOWNERS or similar features. However, it has to be done at a file level because each files are in category folders i.e. `resolvers`, `datasources`, etc.

It is tempting to split this structure up into folders, each managed by a team:

```markdown
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ schema/
â”‚   â”‚   â”œâ”€â”€ TeamA/                # TeamA pinged (by CODEOWNERS) if anything changes in this folder
â”‚   â”‚   â”‚   â”œâ”€â”€ datasources/
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ UserDatasource.ts
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ AuthDatasource.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ resolvers/
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ userResolvers.ts
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ authResolvers.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ userSchema.graphql
â”‚   â”‚   â”‚   â”œâ”€â”€ authSchema.graphql
â”‚   â”‚   â”œâ”€â”€ TeamB/                 # TeamB pinged (by CODEOWNERS) if anything changes in this folder
â”‚   â”‚   â”‚   â”œâ”€â”€ datasources/
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ BookDatasource.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ resolvers/
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ bookResolvers.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ bookSchema.graphql
â”‚   â”œâ”€â”€ server.ts
â”‚   â”œâ”€â”€ codegen.yml
```

This is already a big improvement as ownership is clearer, but there's still organisational problems. For example, what happens when Team A changes what they own? Or split up into smaller teams? Or simply change their name? All of these scenarios require some level of admin work: at least renaming of the folder and at most moving files around, both having no values to end user.

On top of that, all datasources and resolvers must be put together into the GraphQL server. In this case, it's the `server.ts` file. Who owns this file and other maintenance of the server such as `codegen.yml` (we all use GraphQL Codegen right? ðŸ˜‰), package updates, security patches, etc.?

### Solution: Split into Modules

It is fairly common to see teams change name or mission. However, the thing that does not change very often (and in some cases, never!) is business domain. If we split our code based on business domain and assign teams accordingly, it becomes much more scalable.

On the maintenance of the server, it is best to have a small group of dedicated maintainers. This could consist of one member from each team in the codebase and membership can rotate, or another team altogether. Having a dedicated group of maintainers help reduce noise and cognitive load from the rest of the teams.

Using the same example before, we can identify 3 main domains: User, Auth and Book, each have CODEOWNERS set up to notify appropriate teams of changes. The Maintainers own `server.ts` and other configs.

```markdown
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ schema/
â”‚   â”‚   â”œâ”€â”€ user/                      # TeamA pinged if changed
â”‚   â”‚   â”‚   â”œâ”€â”€ datasources/
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ UserDatasource.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ resolvers/
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ userResolvers.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ userSchema.graphql
â”‚   â”‚   â”œâ”€â”€ auth/                      # TeamA pinged if changed
â”‚   â”‚   â”‚   â”œâ”€â”€ datasources/
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ AuthDatasource.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ resolvers/
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ authResolvers.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ authSchema.graphql
â”‚   â”‚   â”œâ”€â”€ book/                      # TeamB pinged if changed
â”‚   â”‚   â”‚   â”œâ”€â”€ datasources/
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ BookDatasource.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ resolvers/
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ bookResolvers.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ bookSchema.graphql
â”‚   â”œâ”€â”€ server.ts                      # Maintainers pinged if changed
â”‚   â”œâ”€â”€ codegen.yml                    # Maintainers pinged if changed
```

## The Hard Problems

Splitting schema into modules is usually easy to get teams to agree on. It is then we start to see the hard problems: enforcing best practices to the teams while reducing the time Maintainers need to spend on server maintenance.

### 1. How to Enforce Best Practices for All Teams

Bad practices and conventions spread like fire, on a hot summer day, in the bush, in Australia. Trust me it is the worst! I used to be part of a Maintainers team. We had guidelines on things like resolver naming convention. Once in a blue moon, one person incorrectly used pascal case instead of camel case. The following day, I woke up with more than half the the resolvers in pascal case ðŸ’€. OK, I am exaggerating here but the experience was very traumatising.

Guidelines alone is only good if people follow it. Without explicit and automatic enforcement, things start to slip and bad practices spread sooner or later. To enforce guidelines, we need tools. Luckily, these days we have an extensive range of tools for best practices a GraphQL server:

*   [GraphQL Codegen](https://the-guild.dev/graphql/codegen) with [typescript](https://the-guild.dev/graphql/codegen/plugins/typescript/typescript) and [typescript-resolvers](https://the-guild.dev/graphql/codegen/plugins/typescript/typescript-resolvers) plugins for type-safe GraphQL server development in TypeScript
*   [GraphQL ESLint](https://github.com/B2o5T/graphql-eslint) for validation and conventions like naming and best practices.

(TODO: Does the below sentences sound too harsh? To both the existing tooling and teams I'm working with?)

However, there are still areas to improve.

For example, the guideline for one of the GraphQL servers I am working on is to use generated types from GraphQL Codegen. However, some people do not follow the guidelines, mostly because they are not aware of it. Luckily, these issues are caught by other team members or the Maintainers at PR review time, but it could have saved everyone time and effort if it was easier.

### 2. How to Minimise Noise to the Maintainers

Maintainers, apart from their their own team's work, usually need to manage many aspects of a GraphQL server:

*   Core server logic
*   `codegen.yml`

Changing anything in these files notifies the Maintainers. Unfortunately, this happens fairly regularly in normal workflows.

For example, if a new resolver is added, they must be manually added to the resolver list that is passed to the server. So Maintainers are notified on every new resolver.

(TODO: not sure if we are ok with calling out the caveats of mergeResolvers from @graphql-tools/merge here)

There is a way to mitigate this issue: each schema module exports an object of resolvers and they are merged with [mergeResolvers from @graphql-tools/merge](https://the-guild.dev/graphql/tools/docs/schema-merging#merging-resolvers). This means the Maintainers are only notified on every new module instead of every resolver. However, `mergeResolvers` has a runtime and since it's simply merging plain JavaScript objects, there is a risk of some one accidentally overriding others' resolvers.

(TODO: Is the a The Guild blog post about GraphQL is more than just forwarding API responses to the client? Or a blog of how mappers work?)

Another commonly used feature is [mappers](https://the-guild.dev/graphql/codegen/plugins/typescript/typescript-resolvers#mappers). Resolvers can return mapper objects instead of GraphQL output types.

The problem with mappers is that every time we need to create one, we need to update `codegen.yml` so it generates the types correctly:

```yaml
generates:
  src/schema/types.generated.ts:
    plugins:
      - typescript
      - typescript-resolvers
    mappers:
      User: './mappers#UserMapper'
      Profile: './mappers#ProfileMapper'
      # one line for each mapper
```

This is a problem for the Maintainers because these changes are based on teams' requirements. Whether a team uses mappers or not is the team's choice and should not concern the Maintainers. Yet, the Maintainers and notified because they manage the `codegen.yml` file.

### Solution: Use Server Preset

To solve the above problems, I am working on a preset for GraphQL server: [@eddeee888/gcg-typescript-resolver-files](https://www.npmjs.com/package/@eddeee888/gcg-typescript-resolver-files). The aim is to move from guidelines and config to enforceable conventions. All changes happen inside teams' modules so feature work does not notify the Maintainer.

This works for any GraphQL server implementation such as GraphQL Yoga, Apollo Server, etc.

Here's how to get started:

```bash
yarn add -D @graphql-codegen/cli @eddeee888/gcg-typescript-resolver-files
```

Then, you can add the following config:

```yaml
schema: 'src/**/*.graphql'
generates:
  src/schema:
    preset: '@eddeee888/gcg-typescript-resolver-files'
```

Note that this preset includes `@graphql-codegen/typescript` and `@graphql-codegen/typescript-resolvers` under the hood so you do not have to set that up manually!

Now, all we have to do is to set up schema modules like this:

```markdown
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ schema/
â”‚   â”‚   â”œâ”€â”€ base/
â”‚   â”‚   â”‚   â”œâ”€â”€ schema.graphql
â”‚   â”‚   â”œâ”€â”€ user/
â”‚   â”‚   â”‚   â”œâ”€â”€ schema.graphql
â”‚   â”‚   â”œâ”€â”€ book/
â”‚   â”‚   â”‚   â”œâ”€â”€ schema.graphql
```

Given the following content of schema files:

```graphql
# base.graphql
type Query
type Mutation

# user.graphql
extend type Query {
  user(id: ID!): User
}
type User {
  id: ID!
  fullName: String!
}

# book.graphql
extend type Query {
  book(id: ID!): Book
}
extend type Mutation {
  markBookAsRead(id: ID!): Book!
}
type Book {
  id: ID!
  isbn: String!
}
```

When we run codegen:

```bash
yarn codegen
```

We will see the following files:

```markdown
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ schema/
â”‚   â”‚   â”œâ”€â”€ base/
â”‚   â”‚   â”‚   â”œâ”€â”€ schema.graphql
â”‚   â”‚   â”œâ”€â”€ user/
â”‚   â”‚   â”‚   â”œâ”€â”€ resolvers/
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ Query/
â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ user.ts            # Generated
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ User.ts                # Generated
â”‚   â”‚   â”‚   â”œâ”€â”€ schema.graphql
â”‚   â”‚   â”œâ”€â”€ book/
â”‚   â”‚   â”‚   â”œâ”€â”€ resolvers/
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ Query/
â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ book.ts            # Generated
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ Mutation/
â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ markBookAsRead.ts  # Generated
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ Book.ts                # Generated      
â”‚   â”‚   â”‚   â”œâ”€â”€ schema.graphql
â”‚   â”‚   â”œâ”€â”€ types.generated.ts             # Generated
â”‚   â”‚   â”œâ”€â”€ resolvers.generated.ts         # Generated
```

#### Generated Files

*   Shared schema and resolver TypeScript types: `types.generated.ts`. This is generated by `@graphql-codegen/typescript` and `@graphql-codegen/typescript-resolvers` plugins. This can be ignored in Git or removed from CODEOWNERS because it is fully generated.

*   Resolver list: `resolvers.generated.ts`. This puts all other resolvers together statically, ready to be passed into the GraphQL server. This can be ignored in Git or removed from CODEOWNERS because it is fully generated.

```ts
// src/schema/resolvers.generated.ts
/* This file was automatically generated. DO NOT UPDATE MANUALLY. */
import type { Resolvers } from './types.generated';
import { book as Query_book } from './book/resolvers/Query/book';
import { markBookAsRead as Mutation_markBookAsRead } from './book/resolvers/Mutation/markBookAsRead';
import { Book } from './book/resolvers/Book';
import { user as Query_user } from './user/resolvers/Query/user';
import { User } from './user/resolvers/User';
export const resolvers: Resolvers = {
  Query: {
    book: Query_book,
    user: Query_user,
  },
  Mutation: { 
    markBookAsRead: Mutation_markBookAsRead,
  },

  Book: Book,
  User: User,
};

```

*   Operation resolvers: `src/schema/user/resolvers/Query/user.ts`, `src/schema/book/resolvers/Query/book.ts`, `src/schema/book/resolvers/Mutation/book.ts`

```ts
// Example: src/schema/user/resolvers/Query/user.ts
import type { QueryResolvers } from './../../../types.generated';
export const user: NonNullable<QueryResolvers['user']> = async (_parent, _arg, _ctx) => {
  /* Implement Query.user resolver logic here */
};
```

*   Object type resolvers: `src/schema/user/resolvers/User.ts`, `src/schema/book/resolvers/Book.ts`

```ts
// Example: src/schema/user/resolvers/User.ts
import type { UserResolvers } from './../../types.generated';
export const User: UserResolvers = {
  /* Implement User resolver logic here */
};
```

Now, you can go straight into implementing your resolvers without worrying about types or updating the resolvers list!

The resolver files will not get overwritten on future codegen. However, there are some smarts built-in to ensure resolvers are correctly exported. For example, if we rename `User` to `WrongUser` in `src/schema/user/resolvers/User.ts`, and run codegen, the file will be updated with a warning:

```ts
// Example: src/schema/user/resolvers/User.ts
import type { UserResolvers } from './../../types.generated';
export const WrongUser: UserResolvers = {
  /* Implement User resolver logic here */
};
/* WARNING: The following resolver was missing from this file. Make sure it is properly implemented or there could be runtime errors. */
export const User: UserResolvers = {
  /* Implement User resolver logic here */
};
```

#### Other GraphQL Types

Currently the following types are supported by the preset:

*   Union: A file will be generated for every Union
*   Scalars:
    *   If the Scalar name matches one in [graphql-scalars](https://the-guild.dev/graphql/scalars), it is automatically imported from `graphql-scalars` into resolver list.
    *   If not, a file will be generated for every Scalar

For other currently non-supported types, we can declare them using the `externalResolvers` preset config.

#### Mappers

Mappers can be added by exporting types or interfaces with `Mapper` suffixes from `.mappers.ts` files in each module. For example, `UserMapper` will be used as `User`'s mapper type.

```ts
// src/schema/user/schema.mappers.ts

// This works! This will be used as mapper for `User` object type
export { User as UserMapper } from 'external-module'

// This works! For `User1` object type
export interface User1Mapper { 
  id: string;
}

// This works 2! For `User2` object type
export type User2Mapper = { id: string } 

// This works 3! For `User3` object type
interface User3Mapper {
  id: string;
}
export { User3Mapper }
```

#### Gradual Migration Supported

Do you have existing code and cannot migrate all in one big bang? The preset has `whitelistedModules` and `blacklistedModules` settings to support gradual migration of modules.

#### Customisable Conventions

All of the above conventions are customisable! Check out the documentation for [more options](https://github.com/eddeee888/graphql-code-generator-plugins/tree/master/packages/typescript-resolver-files).

## Summary

In this blog post, we have explored the problems that can happen to a GraphQL server if it is not set up to scale such as ownership, enforcing best practices and minimising noise to Maintainers. We can use the server preset `@eddeee888/gcg-typescript-resolver-files` to solve these problems for GraphQL servers.

Why don't you give it a go and let me know if it works for you?
