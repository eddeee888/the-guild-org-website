---
title: Setting Up GraphQL Server to Scale With GraphQL Codegen Server Preset
authors: eddeee888
tags: [graphql, codegen, node, server, typescript]
date: 2023-01-31
description: Structuring GraphQL server the right way enables many teams to work in harmony while minimising runtime risks.
# image: 
# thumbnail: 
---

When using GraphQL with Microservices architecture, the GraphQL server is usually the central point where teams must develop their own features while avoiding blocking others. Every team has their own standards and practices. Therefore, if the GraphQL server is not set up in a structure to allow it to scale, development slows down dramatically as more time would be spent on admin tasks and not feature work.

In this blog post we explore the common problems GraphQL servers encounter at scale and recommendations on how to solve them.

## The Easy Problem

### How to Manage Code Ownership

Putting multiple teams in one codebase without clear structure and guidelines is a recipe for disaster. The first team in the codebase usually sets it up a structure that works for them. When a second team joins, they most likely just follows the structure that's already there. The same story happens for every team thereafter. After a few more rounds, development slows down, one reviews the structure and finds themselves staring a codebase that was structured by one team, for one team.

Teams also want their team members to be notified when changes that need reviewed, not on every Pull Request (PR). If you have ever been notified for a change that's unrelated to your team, chances are, the codebase is not structured correctly.

In the example below, TeamA is the first to set up the server. They manage `User` and `Auth` related files so they creates `datasources` and `resolvers` folder for these files:

```markdown
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ schema/
â”‚   â”‚   â”œâ”€â”€ datasources/
â”‚   â”‚   â”‚   â”œâ”€â”€ UserDatasource.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ AuthDatasource.ts
â”‚   â”‚   â”œâ”€â”€ resolvers/
â”‚   â”‚   â”‚   â”œâ”€â”€ userResolvers.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ authResolvers.ts
â”‚   â”‚   â”œâ”€â”€ userSchema.graphql
â”‚   â”‚   â”œâ”€â”€ authSchema.graphql
â”‚   â”œâ”€â”€ server.ts
â”‚   â”œâ”€â”€ codegen.yml
```

Then, TeamB comes into the codebase. They manage `Book` related files so they add their files following the same structure:

```markdown
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ schema/
â”‚   â”‚   â”œâ”€â”€ datasources/
â”‚   â”‚   â”‚   â”œâ”€â”€ UserDatasource.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ AuthDatasource.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ BookDatasource.ts
â”‚   â”‚   â”œâ”€â”€ resolvers/
â”‚   â”‚   â”‚   â”œâ”€â”€ userResolvers.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ authResolvers.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ bookResolvers.ts
â”‚   â”‚   â”œâ”€â”€ userSchema.graphql
â”‚   â”‚   â”œâ”€â”€ authSchema.graphql
â”‚   â”‚   â”œâ”€â”€ bookSchema.graphql
â”‚   â”œâ”€â”€ server.ts
â”‚   â”œâ”€â”€ codegen.yml
```

While this works at a small scale where everyone knows each others, it would be hard to know who owns what as their could be hundreds of datasources and resolvers. A simple solution is to assign files to owners using GitHub's CODEOWNERS or similar features. However, it has to be done at a file level because each files are in category folders i.e. `resolvers`, `datasources`, etc.

It is tempting to split this structure up into folders, each managed by a team:

```markdown
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ schema/
â”‚   â”‚   â”œâ”€â”€ TeamA/ # TeamA pinged (by CODEOWNERS) if anything changes in this folder
â”‚   â”‚   â”‚   â”œâ”€â”€ datasources/
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ UserDatasource.ts
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ AuthDatasource.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ resolvers/
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ userResolvers.ts
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ authResolvers.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ userSchema.graphql
â”‚   â”‚   â”‚   â”œâ”€â”€ authSchema.graphql
â”‚   â”‚   â”œâ”€â”€ TeamB/ # TeamB pinged (by CODEOWNERS) if anything changes in this folder
â”‚   â”‚   â”‚   â”œâ”€â”€ datasources/
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ BookDatasource.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ resolvers/
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ bookResolvers.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ bookSchema.graphql
â”‚   â”œâ”€â”€ server.ts
â”‚   â”œâ”€â”€ codegen.yml
```

This is already a big improvement as ownership is clearer, but there's still organisational problems. For example, what happens when Team A changes what they own? Or split up into smaller teams? Or simply change their name? All of these scenarios require some level of admin work: at least renaming of the folder or at most moving files around, both having no values to end user.

On top of that, all datasources and resolvers must be put together into the GraphQL server. In this case, it's the `server.ts` file. Who owns this file and other maintenance of the server such as `codegen.yml` (we all use GraphQL Codegen right? ðŸ˜‰), package updates, security patches, etc.?

### Solution: Split into Modules

It is fairly common to see teams change name or mission. However, the thing that does not change very often (and in some cases, never!) is business domain. If we split our code based on business domain and assign teams accordingly, it becomes much more scalable.

On the maintenance of the server, it is best to have a small group of dedicated maintainers. This could consist of one member from each team in the codebase and membership can rotate, or another team altogether. Having a dedicated group of maintainers help reduce noise and cognitive load to the rest of the teams.

Using the same example before, we can identify 3 main domains: User, Auth and Book, each have CODEOWNERS set up to notify appropriate teams of changes. The Maintainers own `server.ts` and other configs.

```markdown
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ schema/
â”‚   â”‚   â”œâ”€â”€ user/   # TeamA pinged if changed
â”‚   â”‚   â”‚   â”œâ”€â”€ datasources/
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ UserDatasource.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ resolvers/
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ userResolvers.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ userSchema.graphql
â”‚   â”‚   â”œâ”€â”€ auth/   # TeamA pinged if changed
â”‚   â”‚   â”‚   â”œâ”€â”€ datasources/
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ AuthDatasource.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ resolvers/
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ authResolvers.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ authSchema.graphql
â”‚   â”‚   â”œâ”€â”€ book/   # TeamB pinged if changed
â”‚   â”‚   â”‚   â”œâ”€â”€ datasources/
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ BookDatasource.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ resolvers/
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ bookResolvers.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ bookSchema.graphql
â”‚   â”œâ”€â”€ server.ts   # Maintainers pinged if changed
â”‚   â”œâ”€â”€ codegen.yml # Maintainers pinged if changed
```

## The Hard Problems

### 1. How to Enforce Best Practices for All Teams

*   Thanks to GraphQL Codegen, we can generate types for resolvers
*   However, there's no stopping teams from *NOT* using the types

### 2. How to Minimise Noise to the Core Maintainers

*   Core maintainer of the GraphQL server usually need to manage many things:
    *   `codegen.yml`
    *   Main server logic e.g. putting the resolvers together (show an example with GraphQL Yoga)

*   Resolver Problm: adding a new schema module requires wiring up to the main server file/s which requires core maintainer's attention at least once:
    *   If manually putting all resolvers in a file, every new resolver / type pings the core maintainer
    *   If using `mergeResolvers` from `@graphql-tools/merge`, still have to put it in one file. This pings core maintainer for every new module
    *   If using `mergeResolvers` from `@graphql-tools/merge` to automatically merge, can run into issue where a team's resolver overrides others. Give example(?)

*   Explain mappers. Mapper problem: a team needing to add mappers touch `codegen.yml` which requires the core maintainer, or in some cases, all teams to look at the change because this is config
    *   Add example:
        ```yaml
        mappers:
          User: "./mappers#UserMapper"
          Profile: "./mappers#ProfileMapper"
        ```

### Solution: Use Server Preset

*   Use `@eddeee888/gcg-typescript-resolver-files` preset
*   Explain Config to Convention
*   Show how to set up
*   Features:
    *   Resolvers
        *   Resolvers are created in opinionated filesystem structure that's easy to search for.
        *   Resolvers are put together in a generated file that can be ignored. Also no runtime.
        *   Resolvers are guaranteed to exist. Give example
    *   Mappers
        *   Show previous steps that would ping core maintainers (i.e. b/c editing `codegen.yml`)
        *   `.mappers.ts` and `Mapper` suffix are all needed. Does not ping core maintainers
    *   GraphQL Scalars
        *   Uses GraphQL Scalars by default for non-native scalars.
        *   Peer deps so only install if needed.

## Summary
